from fastapi import FastAPI, UploadFile, File, HTTPException, Form, Depends, Request, Header, Query
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse, FileResponse
from fastapi.staticfiles import StaticFiles
from auth import get_current_user
from pydantic import BaseModel
from typing import Optional, List, Dict, Any
import uvicorn
import os
import json
import logging
import shutil
import tempfile
from datetime import datetime
import uuid
import numpy as np
from pathlib import Path

# Audio processing imports
try:
    import librosa
    import soundfile as sf
    from pydub import AudioSegment
    from audio_processing import audio_processor
    from advanced_audio_effects import advanced_effects
    from audio_export import audio_exporter
    from cache_manager import cache_manager
    from parallel_processor import parallel_processor
    from llm_processor import llm_processor
    from extensions_manager import extensions_manager
except ImportError:
    logging.warning("Audio processing libraries not installed. Some features may not work.")
    pass

# Initialize logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)

# Initialize FastAPI app
app = FastAPI(
    title="AudioChat API",
    description="Backend API for AudioChat application - Audio Engineering Assistant",
    version="1.0.0",
)

# Create directories for storing audio files
UPLOAD_DIR = Path("uploads")
PROCESSED_DIR = Path("processed")
UPLOAD_DIR.mkdir(exist_ok=True)
PROCESSED_DIR.mkdir(exist_ok=True)

# Mount static files for serving processed audio
app.mount("/audio", StaticFiles(directory="processed"), name="processed_audio")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, replace with specific origins
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Models
class Message(BaseModel):
    content: str
    role: str = "user"
    model: Optional[str] = None

class ChatRequest(BaseModel):
    messages: List[Dict[str, Any]]
    model: str
    temperature: Optional[float] = 0.7
    max_tokens: Optional[int] = 1000

class TranscriptionRequest(BaseModel):
    audio_file_path: str
    language: Optional[str] = "en"

class TextToSpeechRequest(BaseModel):
    text: str
    voice: Optional[str] = "default"

# Mock database
conversations = {}
api_keys = {}
user_files = {}  # Store user files mapping: user_id -> [file_info]

# Routes
@app.get("/")
async def root():
    return {"message": "Welcome to AudioChat API"}

@app.get("/health")
async def health_check():
    return {"status": "healthy", "timestamp": datetime.now().isoformat()}

# LLM API routes
@app.post("/api/chat")
async def chat(request: ChatRequest):
    """
    Process a chat request with the specified LLM model
    """
    try:
        model = request.model
        logger.info(f"Processing chat request with model: {model}")
        
        # In a real implementation, this would call the appropriate LLM API
        # For now, we'll return a mock response
        response = {
            "id": str(uuid.uuid4()),
            "model": model,
            "created": datetime.now().timestamp(),
            "content": f"This is a mock response from the {model} model. In a real implementation, this would be generated by the LLM API.",
            "role": "assistant"
        }
        
        return response
    except Exception as e:
        logger.error(f"Error processing chat request: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/audio/transcribe")
async def transcribe_audio(file: UploadFile = File(...)):
    """
    Transcribe audio file to text
    """
    try:
        # Save the uploaded file temporarily
        file_path = f"temp_{uuid.uuid4()}.wav"
        with open(file_path, "wb") as f:
            f.write(await file.read())
        
        logger.info(f"Audio file saved to {file_path}")
        
        # In a real implementation, this would call a speech-to-text API
        # For now, we'll return a mock transcription
        transcription = "This is a mock transcription of the uploaded audio file."
        
        # Clean up the temporary file
        os.remove(file_path)
        
        return {"text": transcription}
    except Exception as e:
        logger.error(f"Error transcribing audio: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/audio/synthesize")
async def text_to_speech(request: TextToSpeechRequest):
    """
    Convert text to speech
    """
    try:
        # In a real implementation, this would call a text-to-speech API
        # For now, we'll return a mock audio URL
        audio_url = f"https://example.com/audio/{uuid.uuid4()}.mp3"
        
        return {"audio_url": audio_url}
    except Exception as e:
        logger.error(f"Error synthesizing speech: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

# API key management
@app.post("/api/keys")
async def save_api_key(provider: str = Form(...), key: str = Form(...)):
    """
    Save API key for a provider
    """
    try:
        # In a real implementation, this would securely store the API key
        # For now, we'll just store it in memory
        api_keys[provider] = key
        return {"status": "success", "message": f"API key for {provider} saved successfully"}
    except Exception as e:
        logger.error(f"Error saving API key: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/keys/{provider}")
async def get_api_key(provider: str):
    """
    Get API key for a provider
    """
    if provider not in api_keys:
        raise HTTPException(status_code=404, detail=f"No API key found for {provider}")
    
    # In a real implementation, this would return a masked version of the key
    return {"provider": provider, "key": "********"}

# Conversation management
@app.post("/api/conversations")
async def create_conversation(title: str = Form(...)):
    """
    Create a new conversation
    """
    conversation_id = str(uuid.uuid4())
    conversations[conversation_id] = {
        "id": conversation_id,
        "title": title,
        "created_at": datetime.now().isoformat(),
        "messages": []
    }
    return conversations[conversation_id]

@app.get("/api/conversations")
async def list_conversations():
    """
    List all conversations
    """
    return list(conversations.values())

@app.get("/api/conversations/{conversation_id}")
async def get_conversation(conversation_id: str):
    """
    Get a specific conversation
    """
    if conversation_id not in conversations:
        raise HTTPException(status_code=404, detail="Conversation not found")
    return conversations[conversation_id]

@app.delete("/api/conversations/{conversation_id}")
async def delete_conversation(conversation_id: str):
    """
    Delete a conversation
    """
    if conversation_id not in conversations:
        raise HTTPException(status_code=404, detail="Conversation not found")
    del conversations[conversation_id]
    return {"status": "success", "message": "Conversation deleted"}

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)

# Audio processing models
class AudioProcessingRequest(BaseModel):
    file_id: str
    instructions: str
    effects: Optional[List[Dict[str, Any]]] = None
    segment: Optional[Dict[str, float]] = None  # {"start": start_time_in_seconds, "end": end_time_in_seconds}

class AudioEffect(BaseModel):
    type: str  # eq, compression, reverb, etc.
    parameters: Dict[str, Any]

# Extensions API routes
@app.get("/api/extensions")
async def get_extensions(current_user: dict = Depends(get_current_user)):
    """
    Get all available extensions for the current user
    """
    try:
        user_id = current_user["id"]
        return extensions_manager.get_user_extensions(user_id)
    except Exception as e:
        logger.error(f"Error getting extensions: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/extensions/{extension_id}")
async def get_extension(extension_id: str, current_user: dict = Depends(get_current_user)):
    """
    Get details for a specific extension
    """
    try:
        extension = extensions_manager.get_extension(extension_id)
        if not extension:
            raise HTTPException(status_code=404, detail="Extension not found")
        
        # Check if user has access to premium extension
        user_id = current_user["id"]
        if extension.premium and not extensions_manager.is_extension_enabled(user_id, extension_id):
            extension_dict = extension.to_dict()
            extension_dict["enabled"] = False
            return extension_dict
        
        extension_dict = extension.to_dict()
        extension_dict["enabled"] = extensions_manager.is_extension_enabled(user_id, extension_id)
        return extension_dict
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting extension: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/extensions/{extension_id}/enable")
async def enable_extension(extension_id: str, current_user: dict = Depends(get_current_user)):
    """
    Enable an extension for the current user
    """
    try:
        user_id = current_user["id"]
        success = extensions_manager.enable_extension(user_id, extension_id)
        if not success:
            raise HTTPException(status_code=404, detail="Extension not found")
        
        return {"status": "success", "message": f"Extension {extension_id} enabled"}
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error enabling extension: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/extensions/{extension_id}/disable")
async def disable_extension(extension_id: str, current_user: dict = Depends(get_current_user)):
    """
    Disable an extension for the current user
    """
    try:
        user_id = current_user["id"]
        success = extensions_manager.disable_extension(user_id, extension_id)
        if not success:
            raise HTTPException(status_code=404, detail="Extension not found or not enabled")
        
        return {"status": "success", "message": f"Extension {extension_id} disabled"}
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error disabling extension: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

# Audio file routes with authentication
@app.post("/api/audio/upload")
async def upload_audio(file: UploadFile = File(...), current_user: dict = Depends(get_current_user)):
    """
    Upload an audio file for processing (authenticated)
    """
    try:
        # Validate file size (50MB limit)
        max_size = 50 * 1024 * 1024
        file_content = await file.read()
        if len(file_content) > max_size:
            raise HTTPException(status_code=413, detail="File too large. Maximum size is 50MB.")
        
        # Validate file type
        allowed_types = ['audio/wav', 'audio/mp3', 'audio/mpeg', 'audio/ogg', 'audio/flac', 'audio/aac', 'audio/m4a']
        if file.content_type not in allowed_types:
            raise HTTPException(status_code=400, detail="Invalid file type. Please upload a valid audio file.")
        
        # Generate a unique ID for the file
        file_id = str(uuid.uuid4())
        file_extension = os.path.splitext(file.filename)[1]
        user_id = current_user["id"]
        
        # Create user-specific directory
        user_upload_dir = UPLOAD_DIR / user_id
        user_upload_dir.mkdir(exist_ok=True)
        
        file_path = user_upload_dir / f"{file_id}{file_extension}"
        
        # Save the uploaded file
        with open(file_path, "wb") as f:
            f.write(file_content)
        
        logger.info(f"Audio file saved to {file_path} for user {user_id}")
        
        # Get basic audio information
        try:
            y, sr = librosa.load(file_path, sr=None)
            duration = librosa.get_duration(y=y, sr=sr)
            
            # Generate waveform data for visualization (downsampled)
            waveform = librosa.resample(y, orig_sr=sr, target_sr=100)
            waveform = waveform[:1000].tolist()  # Limit number of points
            
            audio_info = {
                "file_id": file_id,
                "filename": file.filename,
                "duration": duration,
                "sample_rate": sr,
                "channels": 1 if len(y.shape) == 1 else y.shape[0],
                "waveform": waveform,
                "size": len(file_content),
                "uploaded_at": datetime.now().isoformat(),
                "user_id": user_id
            }
        except Exception as e:
            logger.error(f"Error analyzing audio: {str(e)}")
            audio_info = {
                "file_id": file_id,
                "filename": file.filename,
                "size": len(file_content),
                "uploaded_at": datetime.now().isoformat(),
                "user_id": user_id
            }
        
        # Store file info in user files database
        if user_id not in user_files:
            user_files[user_id] = []
        user_files[user_id].append(audio_info)
        
        return audio_info
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error uploading audio: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/audio/process")
async def process_audio(request: AudioProcessingRequest, current_user: dict = Depends(get_current_user)):
    """
    Process an audio file based on natural language instructions (authenticated)
    Uses advanced audio processing capabilities to interpret and apply effects
    Supports processing specific segments of audio
    Uses cache for improved performance
    """
    try:
        # Find the original file in user's directory
        file_id = request.file_id
        user_id = current_user["id"]
        user_upload_dir = UPLOAD_DIR / user_id
        
        # Check cache first if not using custom effects
        if not request.effects:
            cached_audio = cache_manager.get_processed_audio(
                file_id, 
                request.instructions,
                segment=request.segment
            )
            
            if cached_audio:
                logger.info(f"Using cached processed audio for file {file_id}")
                audio_data, sample_rate = cached_audio
                
                # Get cached analysis or generate new one
                audio_analysis = cache_manager.get_audio_analysis(file_id)
                if not audio_analysis:
                    audio_analysis = audio_processor.analyze_audio(audio_data, sample_rate)
                    cache_manager.cache_audio_analysis(file_id, audio_analysis)
                
                # Generate a new file ID for the cached result
                processed_file_id = str(uuid.uuid4())
                file_extension = ".wav"  # Default to WAV for cached audio
                processed_file_path = PROCESSED_DIR / f"{processed_file_id}{file_extension}"
                
                # Save the processed audio
                sf.write(processed_file_path, audio_data, sample_rate)
                
                # Extract processing steps from cache or generate placeholder
                processing_steps = request.instructions.split('\n')
                
                # Generate response with processing details
                response = {
                    "original_file_id": file_id,
                    "processed_file_id": processed_file_id,
                    "processing_steps": processing_steps,
                    "audio_url": f"/audio/{processed_file_path.name}",
                    "instructions": request.instructions,
                    "audio_analysis": audio_analysis,
                    "segment": request.segment,
                    "cached": True
                }
                
                return response
        
        # If not in cache, process the audio
        original_files = list(user_upload_dir.glob(f"{file_id}.*"))
        
        if not original_files:
            raise HTTPException(status_code=404, detail="Audio file not found")
        
        original_file = original_files[0]
        file_extension = original_file.suffix
        
        # Load the audio file
        y, sr = librosa.load(original_file, sr=None)
        
        # Extract segment if specified
        full_audio = y.copy()
        segment_info = None
        
        if request.segment:
            start_time = request.segment.get("start", 0)
            end_time = request.segment.get("end", None)
            
            # Convert time to samples
            start_sample = int(start_time * sr)
            
            if end_time is not None:
                end_sample = int(end_time * sr)
                # Ensure end sample is within bounds
                end_sample = min(end_sample, len(y))
            else:
                end_sample = len(y)
            
            # Extract segment
            y = y[start_sample:end_sample]
            
            # Save segment info for response
            segment_info = {
                "start": start_time,
                "end": end_time if end_time is not None else start_time + (len(y) / sr),
                "duration": len(y) / sr
            }
            
            logger.info(f"Processing segment: {start_time}s to {segment_info['end']}s")
        
        # Check if analysis is cached
        audio_analysis = cache_manager.get_audio_analysis(file_id)
        if not audio_analysis:
            # Analyze the audio to get its characteristics
            audio_analysis = audio_processor.analyze_audio(y, sr)
            # Cache the analysis
            cache_manager.cache_audio_analysis(file_id, audio_analysis)
            
        logger.info(f"Audio analysis: {audio_analysis}")
        
        # Process the audio using our advanced audio processor
        # Check if file is large enough to benefit from parallel processing
        is_large_file = len(y) > sr * 30  # Files longer than 30 seconds
        
        if is_large_file:
            logger.info(f"Using parallel processing for large file: {len(y)/sr:.2f} seconds")
            
            if request.effects:
                # Use explicitly provided effects chain with parallel processing
                processed_audio = parallel_processor.process_audio_with_effects_parallel(
                    y, sr, request.effects
                )
                # Get processing steps from effects
                processing_steps = [f"Applied {effect['type']} effect" for effect in request.effects]
            else:
                # Parse natural language instructions using LLM
                effects_chain = llm_processor.process_instructions(request.instructions, audio_analysis)
                
                # Then apply effects in parallel
                processed_audio = parallel_processor.process_audio_with_effects_parallel(
                    y, sr, effects_chain
                )
                
                # Generate processing steps descriptions
                processing_steps = [audio_processor.describe_effect(effect["type"], effect["parameters"]) 
                                   for effect in effects_chain]
        else:
            # For smaller files, use regular processing
            if request.effects:
                # Use explicitly provided effects chain
                processed_audio, processing_steps = audio_processor.process_audio(
                    y, sr, request.instructions, request.effects
                )
            else:
                # Otherwise, parse natural language instructions
                processed_audio, processing_steps = audio_processor.process_audio(
                    y, sr, request.instructions
                )
        
        # If we processed a segment, merge it back into the full audio
        if segment_info:
            start_sample = int(segment_info["start"] * sr)
            end_sample = start_sample + len(processed_audio)
            
            # Create a copy of the full audio and replace the segment
            merged_audio = full_audio.copy()
            merged_audio[start_sample:end_sample] = processed_audio
            processed_audio = merged_audio
        
        # Cache the processed audio
        cache_manager.cache_processed_audio(
            file_id,
            request.instructions,
            processed_audio,
            sr,
            effects=request.effects,
            segment=segment_info
        )
        
        # Save the processed audio
        processed_file_id = str(uuid.uuid4())
        processed_file_path = PROCESSED_DIR / f"{processed_file_id}{file_extension}"
        sf.write(processed_file_path, processed_audio, sr)
        
        # Generate response with processing details
        response = {
            "original_file_id": file_id,
            "processed_file_id": processed_file_id,
            "processing_steps": processing_steps,
            "audio_url": f"/audio/{processed_file_path.name}",
            "instructions": request.instructions,
            "audio_analysis": audio_analysis,
            "segment": segment_info,
            "cached": False
        }
        
        return response
    except Exception as e:
        logger.error(f"Error processing audio: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

# User file management endpoints
@app.get("/api/user/files")
async def get_user_files(current_user: dict = Depends(get_current_user)):
    """
    Get all files for the authenticated user
    """
    try:
        user_id = current_user["id"]
        return user_files.get(user_id, [])
    except Exception as e:
        logger.error(f"Error retrieving user files: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.delete("/api/user/files/{file_id}")
async def delete_user_file(file_id: str, current_user: dict = Depends(get_current_user)):
    """
    Delete a user's file
    """
    try:
        user_id = current_user["id"]
        
        # Find and remove file from user's file list
        if user_id in user_files:
            user_files[user_id] = [f for f in user_files[user_id] if f["file_id"] != file_id]
        
        # Delete physical file
        user_upload_dir = UPLOAD_DIR / user_id
        file_deleted = False
        
        for file_path in user_upload_dir.glob(f"{file_id}.*"):
            file_path.unlink()
            file_deleted = True
            logger.info(f"Deleted file {file_path} for user {user_id}")
        
        if not file_deleted:
            raise HTTPException(status_code=404, detail="File not found")
        
        return {"status": "success", "message": "File deleted successfully"}
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error deleting user file: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/audio/{file_id}")
async def get_audio_file(file_id: str, current_user: dict = Depends(get_current_user)):
    """
    Get an audio file by ID (authenticated)
    """
    try:
        user_id = current_user["id"]
        
        # Check processed files first
        processed_files = list(PROCESSED_DIR.glob(f"{file_id}.*"))
        if processed_files:
            return FileResponse(processed_files[0])
            
        # Then check user's original files
        user_upload_dir = UPLOAD_DIR / user_id
        original_files = list(user_upload_dir.glob(f"{file_id}.*"))
        if original_files:
            return FileResponse(original_files[0])
            
        raise HTTPException(status_code=404, detail="Audio file not found")
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error retrieving audio file: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/audio/{file_id}/waveform")
async def get_audio_waveform(file_id: str, points: int = 1000, current_user: dict = Depends(get_current_user)):
    """
    Get waveform data for visualization (authenticated)
    Uses cache for improved performance
    """
    try:
        user_id = current_user["id"]
        
        # Check cache first
        cached_waveform = cache_manager.get_waveform_data(file_id, points)
        if cached_waveform:
            logger.info(f"Using cached waveform data for file {file_id}")
            return cached_waveform
        
        # Find the file
        processed_files = list(PROCESSED_DIR.glob(f"{file_id}.*"))
        
        # Check user's original files
        user_upload_dir = UPLOAD_DIR / user_id
        original_files = list(user_upload_dir.glob(f"{file_id}.*"))
        
        file_path = None
        if processed_files:
            file_path = processed_files[0]
        elif original_files:
            file_path = original_files[0]
        else:
            raise HTTPException(status_code=404, detail="Audio file not found")
            
        # Load and downsample the audio
        y, sr = librosa.load(file_path, sr=None)
        
        # Generate waveform data (downsampled)
        waveform = librosa.resample(y, orig_sr=sr, target_sr=points/librosa.get_duration(y=y, sr=sr))
        waveform = waveform[:points].tolist()
        
        waveform_data = {
            "file_id": file_id,
            "waveform": waveform,
            "sample_rate": sr,
            "duration": librosa.get_duration(y=y, sr=sr)
        }
        
        # Cache the waveform data
        cache_manager.cache_waveform_data(file_id, waveform_data, points)
        
        return waveform_data
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error generating waveform: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/audio/export")
async def export_audio(
    file_id: str = Form(...),
    format: str = Form(...),
    quality: str = Form("high"),
    current_user: dict = Depends(get_current_user)
):
    """
    Export audio file in different formats and quality settings
    
    Args:
        file_id: ID of the audio file to export
        format: Output format ('wav', 'mp3', 'flac', 'ogg', 'aac')
        quality: Quality setting ('low', 'medium', 'high')
    """
    try:
        user_id = current_user["id"]
        
        # Find the file (check processed files first, then user's original files)
        file_path = None
        
        # Check processed files first
        processed_files = list(PROCESSED_DIR.glob(f"{file_id}.*"))
        if processed_files:
            file_path = processed_files[0]
        else:
            # Then check user's original files
            user_upload_dir = UPLOAD_DIR / user_id
            original_files = list(user_upload_dir.glob(f"{file_id}.*"))
            if original_files:
                file_path = original_files[0]
        
        if not file_path:
            raise HTTPException(status_code=404, detail="Audio file not found")
        
        # Load the audio file
        y, sr = librosa.load(file_path, sr=None)
        
        # Export the audio in the requested format
        export_result = audio_exporter.export_audio(
            audio_data=y,
            sample_rate=sr,
            file_id=f"export_{file_id}",
            format=format,
            quality=quality
        )
        
        return export_result
    except Exception as e:
        logger.error(f"Error exporting audio: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/audio/formats")
async def get_supported_formats():
    """
    Get list of supported audio export formats
    """
    formats = [
        {
            "id": "wav",
            "name": "WAV",
            "description": "Uncompressed audio format with highest quality",
            "qualities": [
                {"id": "low", "name": "Low (16-bit)", "description": "16-bit PCM"},
                {"id": "medium", "name": "Medium (24-bit)", "description": "24-bit PCM"},
                {"id": "high", "name": "High (32-bit float)", "description": "32-bit floating point"}
            ]
        },
        {
            "id": "mp3",
            "name": "MP3",
            "description": "Compressed audio format with good compatibility",
            "qualities": [
                {"id": "low", "name": "Low (128kbps)", "description": "128kbps bitrate"},
                {"id": "medium", "name": "Medium (192kbps)", "description": "192kbps bitrate"},
                {"id": "high", "name": "High (320kbps)", "description": "320kbps bitrate"}
            ]
        },
        {
            "id": "flac",
            "name": "FLAC",
            "description": "Lossless compressed audio format",
            "qualities": [
                {"id": "medium", "name": "Standard", "description": "Standard compression level"},
                {"id": "high", "name": "Best", "description": "Best compression level"}
            ]
        },
        {
            "id": "ogg",
            "name": "OGG Vorbis",
            "description": "Free and open-source compressed audio format",
            "qualities": [
                {"id": "low", "name": "Low (96kbps)", "description": "96kbps bitrate"},
                {"id": "medium", "name": "Medium (160kbps)", "description": "160kbps bitrate"},
                {"id": "high", "name": "High (256kbps)", "description": "256kbps bitrate"}
            ]
        },
        {
            "id": "aac",
            "name": "AAC",
            "description": "Advanced Audio Coding format used by Apple",
            "qualities": [
                {"id": "low", "name": "Low (128kbps)", "description": "128kbps bitrate"},
                {"id": "medium", "name": "Medium (192kbps)", "description": "192kbps bitrate"},
                {"id": "high", "name": "High (256kbps)", "description": "256kbps bitrate"}
            ]
        }
    ]
    
    return formats

@app.post("/api/audio/separate")
async def separate_audio_sources(
    file_id: str = Form(...),
    mode: str = Form("2stems"),
    current_user: dict = Depends(get_current_user)
):
    """
    Separate audio into different sources (vocals, accompaniment, etc.)
    
    Args:
        file_id: ID of the audio file to separate
        mode: Separation mode ('2stems', '4stems', or '5stems')
    """
    try:
        user_id = current_user["id"]
        user_upload_dir = UPLOAD_DIR / user_id
        
        # Find the file
        original_files = list(user_upload_dir.glob(f"{file_id}.*"))
        
        if not original_files:
            raise HTTPException(status_code=404, detail="Audio file not found")
        
        original_file = original_files[0]
        file_extension = original_file.suffix
        
        # Load the audio file
        y, sr = librosa.load(original_file, sr=None)
        
        # Separate sources
        sources = advanced_effects.separate_sources(y, sr, mode)
        
        # Save each source as a separate file
        result = {
            "original_file_id": file_id,
            "sources": {}
        }
        
        for source_name, source_data in sources.items():
            if source_name == "original":
                continue
                
            # Generate a unique ID for this source
            source_id = f"{file_id}_{source_name}"
            source_path = PROCESSED_DIR / f"{source_id}{file_extension}"
            
            # Save the source
            sf.write(source_path, source_data, sr)
            
            # Add to result
            result["sources"][source_name] = {
                "file_id": source_id,
                "audio_url": f"/audio/{source_path.name}"
            }
        
        return result
    except Exception as e:
        logger.error(f"Error separating audio sources: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/audio/enhance-vocals")
async def enhance_vocals(
    file_id: str = Form(...),
    strength: float = Form(0.5),
    current_user: dict = Depends(get_current_user)
):
    """
    Enhance vocals in audio
    
    Args:
        file_id: ID of the audio file to enhance
        strength: Enhancement strength (0.0 to 1.0)
    """
    try:
        user_id = current_user["id"]
        user_upload_dir = UPLOAD_DIR / user_id
        
        # Find the file
        original_files = list(user_upload_dir.glob(f"{file_id}.*"))
        
        if not original_files:
            raise HTTPException(status_code=404, detail="Audio file not found")
        
        original_file = original_files[0]
        file_extension = original_file.suffix
        
        # Load the audio file
        y, sr = librosa.load(original_file, sr=None)
        
        # Enhance vocals
        enhanced = advanced_effects.enhance_vocals(y, sr, strength)
        
        # Save the enhanced audio
        enhanced_id = str(uuid.uuid4())
        enhanced_path = PROCESSED_DIR / f"{enhanced_id}{file_extension}"
        sf.write(enhanced_path, enhanced, sr)
        
        return {
            "original_file_id": file_id,
            "enhanced_file_id": enhanced_id,
            "audio_url": f"/audio/{enhanced_path.name}",
            "strength": strength
        }
    except Exception as e:
        logger.error(f"Error enhancing vocals: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/audio/isolate-instrument")
async def isolate_instrument(
    file_id: str = Form(...),
    instrument: str = Form("vocals"),
    current_user: dict = Depends(get_current_user)
):
    """
    Isolate a specific instrument from audio
    
    Args:
        file_id: ID of the audio file to process
        instrument: Instrument to isolate ('vocals', 'drums', 'bass', 'piano', 'other')
    """
    try:
        user_id = current_user["id"]
        user_upload_dir = UPLOAD_DIR / user_id
        
        # Find the file
        original_files = list(user_upload_dir.glob(f"{file_id}.*"))
        
        if not original_files:
            raise HTTPException(status_code=404, detail="Audio file not found")
        
        original_file = original_files[0]
        file_extension = original_file.suffix
        
        # Load the audio file
        y, sr = librosa.load(original_file, sr=None)
        
        # Isolate instrument
        isolated = advanced_effects.isolate_instrument(y, sr, instrument)
        
        # Save the isolated audio
        isolated_id = str(uuid.uuid4())
        isolated_path = PROCESSED_DIR / f"{isolated_id}{file_extension}"
        sf.write(isolated_path, isolated, sr)
        
        return {
            "original_file_id": file_id,
            "isolated_file_id": isolated_id,
            "audio_url": f"/audio/{isolated_path.name}",
            "instrument": instrument
        }
    except Exception as e:
        logger.error(f"Error isolating instrument: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/audio/remove-instrument")
async def remove_instrument(
    file_id: str = Form(...),
    instrument: str = Form("vocals"),
    current_user: dict = Depends(get_current_user)
):
    """
    Remove a specific instrument from audio
    
    Args:
        file_id: ID of the audio file to process
        instrument: Instrument to remove ('vocals', 'drums', 'bass', 'piano', 'other')
    """
    try:
        user_id = current_user["id"]
        user_upload_dir = UPLOAD_DIR / user_id
        
        # Find the file
        original_files = list(user_upload_dir.glob(f"{file_id}.*"))
        
        if not original_files:
            raise HTTPException(status_code=404, detail="Audio file not found")
        
        original_file = original_files[0]
        file_extension = original_file.suffix
        
        # Load the audio file
        y, sr = librosa.load(original_file, sr=None)
        
        # Remove instrument
        processed = advanced_effects.remove_instrument(y, sr, instrument)
        
        # Save the processed audio
        processed_id = str(uuid.uuid4())
        processed_path = PROCESSED_DIR / f"{processed_id}{file_extension}"
        sf.write(processed_path, processed, sr)
        
        return {
            "original_file_id": file_id,
            "processed_file_id": processed_id,
            "audio_url": f"/audio/{processed_path.name}",
            "instrument_removed": instrument
        }
    except Exception as e:
        logger.error(f"Error removing instrument: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/audio/denoise")
async def denoise_audio(
    file_id: str = Form(...),
    strength: float = Form(0.5),
    current_user: dict = Depends(get_current_user)
):
    """
    Remove noise from audio
    
    Args:
        file_id: ID of the audio file to denoise
        strength: Denoising strength (0.0 to 1.0)
    """
    try:
        user_id = current_user["id"]
        user_upload_dir = UPLOAD_DIR / user_id
        
        # Find the file
        original_files = list(user_upload_dir.glob(f"{file_id}.*"))
        
        if not original_files:
            raise HTTPException(status_code=404, detail="Audio file not found")
        
        original_file = original_files[0]
        file_extension = original_file.suffix
        
        # Load the audio file
        y, sr = librosa.load(original_file, sr=None)
        
        # Denoise audio
        denoised = advanced_effects.denoise_audio(y, sr, strength)
        
        # Save the denoised audio
        denoised_id = str(uuid.uuid4())
        denoised_path = PROCESSED_DIR / f"{denoised_id}{file_extension}"
        sf.write(denoised_path, denoised, sr)
        
        return {
            "original_file_id": file_id,
            "denoised_file_id": denoised_id,
            "audio_url": f"/audio/{denoised_path.name}",
            "strength": strength
        }
    except Exception as e:
        logger.error(f"Error denoising audio: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/audio/harmonize")
async def harmonize_audio(
    file_id: str = Form(...),
    semitones: str = Form("4,7"),
    current_user: dict = Depends(get_current_user)
):
    """
    Add harmonies to audio (primarily for vocals)
    
    Args:
        file_id: ID of the audio file to harmonize
        semitones: Comma-separated list of semitone shifts for harmonies
    """
    try:
        user_id = current_user["id"]
        user_upload_dir = UPLOAD_DIR / user_id
        
        # Find the file
        original_files = list(user_upload_dir.glob(f"{file_id}.*"))
        
        if not original_files:
            raise HTTPException(status_code=404, detail="Audio file not found")
        
        original_file = original_files[0]
        file_extension = original_file.suffix
        
        # Load the audio file
        y, sr = librosa.load(original_file, sr=None)
        
        # Parse semitones
        semitone_list = [int(s.strip()) for s in semitones.split(",")]
        
        # Harmonize audio
        harmonized = advanced_effects.harmonize_audio(y, sr, semitone_list)
        
        # Save the harmonized audio
        harmonized_id = str(uuid.uuid4())
        harmonized_path = PROCESSED_DIR / f"{harmonized_id}{file_extension}"
        sf.write(harmonized_path, harmonized, sr)
        
        return {
            "original_file_id": file_id,
            "harmonized_file_id": harmonized_id,
            "audio_url": f"/audio/{harmonized_path.name}",
            "semitones": semitone_list
        }
    except Exception as e:
        logger.error(f"Error harmonizing audio: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/audio/capabilities")
async def get_audio_capabilities():
    """
    Get available audio processing capabilities
    """
    capabilities = {
        "pedalboard_available": advanced_effects.pedalboard_available,
        "spleeter_available": advanced_effects.spleeter_available,
        "librosa_available": advanced_effects.librosa_available,
        "effects": [
            "eq", "compression", "reverb", "delay", "distortion",
            "chorus", "phaser", "filter", "pitch_shift", "gain"
        ],
        "source_separation": advanced_effects.spleeter_available,
        "vocal_enhancement": advanced_effects.spleeter_available,
        "instrument_isolation": advanced_effects.spleeter_available,
        "denoising": advanced_effects.librosa_available,
        "harmonization": advanced_effects.spleeter_available and advanced_effects.librosa_available,
        "parallel_processing": True,
        "caching": True
    }
    
    return capabilities

# Extensions API routes
@app.get("/api/extensions")
async def get_extensions(current_user: dict = Depends(get_current_user)):
    """
    Get all available extensions for the current user
    """
    try:
        user_id = current_user["id"]
        extensions = extensions_manager.get_user_extensions(user_id)
        return extensions
    except Exception as e:
        logger.error(f"Error getting extensions: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/extensions/{extension_id}")
async def get_extension(extension_id: str, current_user: dict = Depends(get_current_user)):
    """
    Get details for a specific extension
    """
    try:
        extension = extensions_manager.get_extension(extension_id)
        if not extension:
            raise HTTPException(status_code=404, detail="Extension not found")
        
        user_id = current_user["id"]
        extension_dict = extension.to_dict()
        extension_dict["enabled"] = extensions_manager.is_extension_enabled(user_id, extension_id)
        
        return extension_dict
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting extension: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/extensions/{extension_id}/enable")
async def enable_extension(extension_id: str, current_user: dict = Depends(get_current_user)):
    """
    Enable an extension for the current user
    """
    try:
        user_id = current_user["id"]
        
        # Check if extension exists
        extension = extensions_manager.get_extension(extension_id)
        if not extension:
            raise HTTPException(status_code=404, detail="Extension not found")
        
        # Check if premium (in a real implementation, check if user has purchased)
        if extension.premium:
            # For now, we'll allow it for development purposes
            # In production, check subscription status here
            pass
        
        # Enable extension
        success = extensions_manager.enable_extension(user_id, extension_id)
        if not success:
            raise HTTPException(status_code=400, detail="Failed to enable extension")
        
        return {"status": "success", "message": f"Extension {extension_id} enabled"}
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error enabling extension: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/extensions/{extension_id}/disable")
async def disable_extension(extension_id: str, current_user: dict = Depends(get_current_user)):
    """
    Disable an extension for the current user
    """
    try:
        user_id = current_user["id"]
        
        # Disable extension
        success = extensions_manager.disable_extension(user_id, extension_id)
        if not success:
            raise HTTPException(status_code=400, detail="Failed to disable extension")
        
        return {"status": "success", "message": f"Extension {extension_id} disabled"}
    except Exception as e:
        logger.error(f"Error disabling extension: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/extensions/categories")
async def get_extension_categories():
    """
    Get all extension categories
    """
    try:
        # Get unique categories from all extensions
        categories = set()
        for extension in extensions_manager.extensions.values():
            categories.add(extension.category)
        
        return list(categories)
    except Exception as e:
        logger.error(f"Error getting extension categories: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))